# PART II. 몽고DB 개발

# 인덱싱

## 인덱싱 소개

> 인덱스를 사용하지 않는 쿼리를 컬렉션 스캔이라 하며,
>
> 서버가 쿼리 결과를 찾으려면 '전체 내용을 살펴봐야 함'을 의미

1️⃣ 인덱스 생성

> 인덱스를 만들려면 `createIndex` 컬렉션 메서드를 사용

```sql
db.users.createIndex({"username" : 1})
```

- 다른 셸에서 db.currentOp()를 실행하거나 mongod의 로그를 확인해 인덱스 구축의 진행률 체크 가능

인덱스는 쿼리 시간에 놀라운 차이를 만든다.
- 단점이라면, 인덱싱된 필드를 변경하는 쓰기(삽입, 갱신, 삭제) 작업은 오래 걸린다.
  - 데이터가 변경될 때마다 도큐먼트뿐 아니라 모든 인덱스를 갱신 필요
- 어떤 필드가 인덱싱하기에 적합한지 신중이 파악이 필요

{% hint style="info" %}

**몽고DB 인덱스**

전형적인 관계형 데이터베이스의 인덱스와 거의 동일하게 작동

{% endhint %}

인덱스를 생성할 필드를 선택하려면, 자주 쓰는 쿼리와 빨리 수행해야 하는 쿼리를 조사해 공통적인 키 셋을 찾아보자.

.

2️⃣ 복합 인덱스

> 두 개 이상의 필드로 구성된 인덱스
>
> 쿼리에서 정렬 방향이 여러 개이거나 검색 조건에 여러 개의 키가 있을 때 유용

몽고DB가 실행하는 쿼리 종류에 따라 인덱스를 사용하는 방법이 다른데 가장 많이 사용하는 세 가지 방법을 보자.

👉🏻 **단일 값을 찾는 동등 쿼리**

```sql
db.users.find({"age": 21}).sort({"username": -1})
```

👉🏻 **범용 쿼리**

```sql
db.users.find({"age": {"$gte": 31, "$lte": 30}})
```

👉🏻 **정렬이 포함된 다중값 쿼리**
- 결과를 반환하기 전에 메모리에서 정렬 작업을 수행하여 정렬 시간이 소요
- 속도는 검색 조건과 일치하는 결과가 얼마나 많은지에 따라 다름

```sql
db.users.find({"age": {"$gte": 31, "$lte": 30}}).sort({"username": 1})
```

{% hint style="info" %}

복합 인덱스를 구성할 때는 정렬 키를 첫 번째에 놓으면 좋다.

{% endhint %}

.

4️⃣ 복합 인덱스 사용

- 읽기, 쓰기를 가능한 효율적으로 수행하도록 인덱스를 설계하자.
- 인덱스의 선택성을 고려하자.
- 커서 hint 메서드를 사용하면 모양이나 이름을 지정함으로써 사용할 인덱스 지정 가능
- `planCacheSetFilter` 함수를 인덱스 필터와 함께 사용하면, 쿼리 옵티마이저가 인덱스 필터에 지정된 인덱스만 고려하도록 제안 가능

모든 데이터셋에 해당되지는 않지만, 일반적으로 동등 필터를 사용할 필드가 다중값 필터를 사용할 필드보다 앞에 오도록 복합 인덱스를 설계해야 한다.
- 복합 인덱스 설계 시 인덱스를 사용할 공통 쿼리 패턴의 동등 필터, 다중값 필터, 정렬 구성 요소를 처리하는 방법을 알아야 한다.
- 인덱스를 더 잘 설계하면 인메모리 정렬을 피할 수 있다.

```sql
db.students.createIndex({class_id:1, student_id:1})
```

{% hint style="info" %}

**복합 인덱스 설계 시**

- 동등 필터에 대한 키를 맨 앞에 표시하자.
- 정렬에 사용되는 키는 다중값 필드 앞에 표시하자.
- 다중값 필터에 대한 키는 마지막에 표시하자.

지침에 따라 복합 인덱스 설계 후, 인덱스가 지원하는 쿼리 패턴의 범위를 실제 워크로드에서 테스트하자.

{% endhint %}

**키 방향 선택하기**

- 복합 정렬을 서로 다른 방향으로 최적화하려면 방향이 맞는 인덱스를 사용해야 한다.
- 인덱스 방향은 다중 조건에 따라 정렬할 때만 문제가 된다.
- 단일 키로 정렬하면 몽고DB는 인덱스를 쉽게 역순으로 읽을 수 있다.

**커버트 쿼리 사용하기**

인덱스가 쿼리가 요구하는 값을 모두 포함하면, 쿼리가 커버드 된다고 한다.
- 실무에서는 도큐먼트로 받지 말고 항상 커버드 쿼리(covered query)를 사용하자.
- 이 방법으로 작업 셋을 훨씬 작게 만들 수 있다.
- 쿼리가 확실히 인덱스만 사용하게 하려면 "_id" 필드를 반환받지 않도록 반환받을 키를 지정해야 한다.

**암시적 인덱스**

- 여러 키에 필요한 만큼 적용 가능
- 인덱스가 N 개의 키를 가진다면 키들의 앞부분은 '공짜'인덱스가 된다.

```json
// 아래 인덱스가 있다면 
{"a" : 1, "b" : 1, "c" : 1, ... "z" : 1 } 
// 공짜 인덱스를 가짐
{"a" : 1}, {"a" : 1, "b" : 1 }, {"a" : 1, "b" : 1, "c" : 1 }  ...
```

. 

5️⃣ $ 연산자의 인덱스 사용법

**비효율적인 연산자**

- 일반적으로 부정 조건은 비효율적
- "`$ne`" 쿼리는 인덱스를 사용하긴 하지만 잘 활용하지 못 한다.

**범위**

- 복합 인덱스는 몽고DB가 다중 절 쿼리를 더 효율적으로 실행하도록 돕는다.

**OR 쿼리**

- 현재 몽고DB는 쿼리당 하나의 인덱스만 사용 가능
- 유일한 예외는 "`$or`"
  - "`$or`"는 두 개의 쿼리를 수행하고 결과를 합치므로 "`$or`"은 "`$or`"절마다 하나씩 인덱스 사용
- 가능하면 "`$or`"보다는 "`$in`"을 사용하자.
  - 일반적으로 두 번 쿼리해서 결과를 병합하면 한 번 쿼리할 때보다 훨씬 비효율적
  - "`$or`"를 사용해야 한다면 몽고DB가 두 쿼리의 결과를 조사하고 중복을 모두 제거해야 한다.

.

6️⃣ 객체 및 배열 인덱싱

**내장 도큐먼트 인덱싱하기**

- 인덱스는 일반적인 키에 생성될 떄와 동일한 방식으로 내장 도큐먼트에 키 생성 가능
- 서브 필드에 인덱스를 만들어 해당 필드를 이용하는 쿼리의 속도를 높일 수 있다.
- 서브 도큐먼트 전체를 인덱싱하면 서브 도큐먼트 전체에 쿼리할 때만 도움이 된다.

```sql
db.users.createIndex({"loc.city" : 1})
```

**배열 인덱싱하기**

- 배열에도 인덱스 생성 가능
- 인덱스를 사용하면 배열의 특정 요소를 효율적으로 탐색
- 단, 내장 도큐먼트와 달리 배열 전체를 단일 개체처럼 인덱싱 불가
  - 배열 필드 인덱싱은 배열 자체가 아니라 배열의 각 요소를 인뎅싱하기 때문

```sql
db.blog.createIndex({"comments.date" : 1})
```

**다중키 인덱스가 미치는 영향**

- 어떤 도큐먼트가 배열 필드를 인덱스 키로 가지면 인덱스는 즉시 다중키 인덱스로 표시
- 다중키 인덱스는 비다중키 인덱스보다 약간 느릴 수 있음
  - 하나의 도큐먼트를 여러 개의 인덱스 항목이 가리킬 수 있으므로 몽고DB는 결과 반환 전 중복을 제거

## explain 출력

## 인덱스를 생성하지 않는 이유

## 인덱스 종류

## 인덱스 관리

# 특수 인덱스와 컬렉션 유형

## 공간 정보 인덱스

## 전문 검색을 위한 인덱스

## 제한 컬렉션

## TTL 인덱스

## GridFS로 파일 저장하기

# 집계 프로임워크

# 트랜잭션

# 애플리케이션 설계