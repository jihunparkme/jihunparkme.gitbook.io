---
description: 대규모 시스템 설계 기초 12장을 요약한 내용입니다.
---

현재 시장에서 가장 널리 쓰이고 있는 채팅 시스템 몇 가지..
- Whatsapp (왓츠앱)
- Facebook messenger
- Wechat (위챗)
- Line
- Google Hangout
- Discord

# 1단계: 문제 이해 및 설계 범위 확정

지원해야 하는 기능

- 1:1, 그룹 채팅 모두 지원하는 앱(응답지연이 낮은 일대일 채팅 기능)
- 모바일, 웹 모두 지원
- 일별 능동 사용자 수(DAU, Daily Active User) 기준 5천만(50million)명 처리
- 최대 100명까지 그룹 채팅 참여 가능
- 1:1 채팅, 그룹 채팅, 사용자 접속상태 표시 지원
- 메시지 길이는 100,000자 이하
- 채팅 이력은 영원히 보관
- 다양한 단말 지원, 하나의 계정으로 여러 단말에 동시 접속 지원
- 푸시 알림

# 2단계: 개략적 설계안 제시 및 동의 구하기

기본적으로 채팅 서비스는 아래 기능을 제공해야 한다.

- 클라이언트들로부터 메시지 수신
- 메시지 수신자 결정 및 전달
- 수신자가 접속 상태가 아닌 경우 접속할 때까지 해당 메시지 보관

클라이언트(메시지 송/수신 클라이언트)와 채팅 서비스 사이의 관계

<figure><img src="../../.gitbook/assets/system-design-interview/12-2.png" alt=""><figcaption></figcaption></figure>

**메시지 송신 클라이언트**

- 채팅을 시작하려는 클라이언트는 **네트워크 통신 프로토콜**을 사용하여 서비스에 접속
  - 어떤 통신 프로토콜을 사용할 것인가도 중요한 문제
- 메시지 송신 클라이언트는 **클라이언트/서버 애플리케이션에서 요청**을 보내는 역할
- 송신 클라이언트는 메시지를 채팅 서비스에 보낼 때 오랜 세월 검증된 **HTTP 프로토콜**을 사용
  - HTTP는 메시지 전송 용도로 좋은 선택
  - 페이스북 같은 대부분 대중적 채팅 프로그램이 초기에 HTTP 사용
- 채팅 서비스와의 접속에는 **keepalive 헤더**를 사용하면 효율적
  - 클라이언트 서버 사이의 연결을 끊지 않고 계속 유지할 수 있음
  - TCP 접속 과정에서 ㅂ라생하는 핸드셰이크 횟수를 줄일 수도 있음

**메시지 수신 클라이언트**

- HTTP는 클라이언트가 연결을 만드는 프로토콜
  - 서버에서 클라이언트로 임의 시점에 메시지를 보내는 데는 쉽게 쓰일 수 없음
- 서버가 연결을 만드는 것처럼 동작할 수 있도록 하기 위해 많은 기법이 제안
  - polling, long polling, webSocket..

## 폴링

**클라이언트가 주기적으로 서버에게** 새 메시지가 있는지 물어보는 방법

- 폴링 비용은 폴링을 자주하면 할수록 올라간다.
- 답해줄 메시지가 없는 경우 서버 자원이 불필요하게 낭비되는 문제가 존재

<figure><img src="../../.gitbook/assets/system-design-interview/12-3.png" alt=""><figcaption></figcaption></figure>

## 롱 폴링

Long Polling: 폴링의 여러 가지 비효율적인 부분을 보안한 기법

<figure><img src="../../.gitbook/assets/system-design-interview/12-4.png" alt=""><figcaption></figcaption></figure>

클라이언트는 **새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지**한다.
- 클라이언트는 새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내어 모든 절차를 다시 시작

하지만, 이 기법에도 약점이 존재
- 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수 있다.
  - HTTP 서버들은 보통 무상태 서버
  - 로드밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우, 메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와의 롱 폴링 연결을 가지고 있지 않은 서버일 수 있다.
- 서버 입장에서 클라이언트가 연결을 해제했는지 아닌지 알 수 있는 방법이 없다.
- 메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때마다 **주기적으로 서버에 다시 접속하여 비효율적**

## 웹소켓

WebSocket은 서버가 클라이언트에게 비동기(async) 메시지를 보낼 때 가장 널리 사용하는 기술

<figure><img src="../../.gitbook/assets/system-design-interview/12-5.png" alt=""><figcaption></figcaption></figure>

- 웹 소켓 연결은 클라이언트가 시작
  - 한 번 맺어진 연결은 항구적이며 양방향
  - 처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 거져 웹소켓 연결로 업그레이드
  - 항구적인 연결이 만들어지고 나면 서버는 클라이언트에게 비동기적으로 메시지를 전송할 수 있음
- 방화벽이 있는 환경에서도 잘 동작
  - 80, 443처럼 HTTP 혹은 HTTPS 프로토콜이 사용하는 기본 포트번호를 그대로 사용
- 웹소켓은 양방향 메시지 전송까지 가능하므로 HTTP를 고집할 이유는 없다.

웹소켓을 이용하면 메시지를 보낼 떄나 받을 때 동일한 프로토콜을 사용할 수 있음
- 설계뿐 아니라 구현도 단순하고 직관적
- 웹소켓 연결은 항구적응로 유지되어야 하므로 서버 측에서 연결 관리를 효율적으로 해야 함


## 개략적 설계안

**무상태 서비스**

.

**상태 유지 서비스**

.

**제3자 서비스 연동**

.

**규모 확장성**

.

**저장소**


# 3단계: 상세 설계

# 4단계: 마무리