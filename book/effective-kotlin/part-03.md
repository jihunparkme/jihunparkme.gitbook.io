# CHAPTER 3. 효율성

# 7장. 비용 줄이기

비용이 크게 들어가지는 않지만 프로그램을 효율적으로 만들 수 있는 최적화 방법

## Item 45. 불필요한 객체 생성 피하기

불필요한 객체 생성을 피하는 것이 최적화의 관점에서 좋다.

.

👉🏻 **객체 생성 비용은 항상 클까?**

- 어떤 객체를 wrap 하면, 크게 세 가지 비용이 발생
  - 객체는 더 많은 용량을 차지
  - 요소가 캡슐화되어 있다면, 접근에 추가적인 함수 호출이 필요
  - 객체는 생성되어야 함

.

👉🏻 **객체 선언**
- 매 순간 객체를 생성하지 않고, 객체를 재사용하는 간단한 방법은 객체 선언을 사용하는 것(싱글톤)

.

👉🏻 **캐시를 활용하는 팩토리 함수**
- 팩토리 함수는 캐시를 가질 수 있다.
- 실제 stdlib의 emptyList는 이를 활용해서 구현

    ```kotlin
    fun <T> List<T> emptyList() {
        return EMPTY_LIST;
    }
    ```
- 모든 순수 함수는 캐싱을 활용할 수 있는데, 이를 메모이제이션이라고 부름
- 참고로, 메모리가 필요할 때 가비지 컬렉터가 자동으로 메모리를 해제해 주는 `SoftReference`를 사용하면 좋다.
- 캐시는 언제나 메모리와 성능의 트레이드 오프가 발생하므로, 캐시를 잘 설계하는 것은 쉽지 않다.

.

👉🏻 **무거운 객체를 외부 스코프로 보내기**
- 함수가 한 파일에 다른 함수와 함께 있을 때, 함수를 사용하지 않는다면 지연 초기화(lazy initialization)를 적용하여 프로퍼티를 지연되게 만들어서 무거운 클래스 사용을 유용하게 만들 수 있다.

.

👉🏻 **지연 초기화**

```kotlin
class A {
    val b by lazy { B() }
    val c by lazy { C() }
    val d by lazy { D() }

    //...
}
```

- 이처럼 지연되게 만들면, 첫 번째 호출 때 응답 시간이 굉장히 길것이다.
- 그래서 백엔드 애플리케이션에서 좋지 않을 수 있다.
- 또한, 지연되게 만들면 성능 테스트가 복잡해지는 문제가 있다.
- 따라서, 지연 초기화는 상황에 맞게 사용하자.

.

👉🏻 **기본 자료형 사용하기**

|코틀린의 자료형|자바의 자료형|
|---|---|
|Int|int|
|Int?|Integer|
|List<Int>|List<Integer>|

- 이를 알면 랩한 자료형 대신 기본 자료형을 사용하게 코드를 최적화 할 수 있다.
- 따라서, 굉장히 큰 컬렉션을 처리할 때 차이를 확인할 수 있다.
- 결과적으로, 코드와 라이브러리의 성능이 굉장히 중요한 부분에서만 이를 적용하자.

📖 **정리**

> 이러한 최적화에 큰 변경이 필요하거나, 다른 코드에 문제를 일으킬 수 있다면 최적화를 미루는 것도 방법이다.