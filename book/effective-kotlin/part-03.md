# CHAPTER 3. 효율성

# 7장. 비용 줄이기

비용이 크게 들어가지는 않지만 프로그램을 효율적으로 만들 수 있는 최적화 방법

## Item 45. 불필요한 객체 생성 피하기

불필요한 객체 생성을 피하는 것이 최적화의 관점에서 좋다.

.

👉🏻 **객체 생성 비용은 항상 클까?**

- 어떤 객체를 wrap 하면, 크게 세 가지 비용이 발생
  - 객체는 더 많은 용량을 차지
  - 요소가 캡슐화되어 있다면, 접근에 추가적인 함수 호출이 필요
  - 객체는 생성되어야 함

.

👉🏻 **객체 선언**
- 매 순간 객체를 생성하지 않고, 객체를 재사용하는 간단한 방법은 객체 선언을 사용하는 것(싱글톤)

.

👉🏻 **캐시를 활용하는 팩토리 함수**
- 팩토리 함수는 캐시를 가질 수 있다.
- 실제 stdlib의 emptyList는 이를 활용해서 구현

    ```kotlin
    fun <T> List<T> emptyList() {
        return EMPTY_LIST;
    }
    ```
- 모든 순수 함수는 캐싱을 활용할 수 있는데, 이를 메모이제이션이라고 부름
- 참고로, 메모리가 필요할 때 가비지 컬렉터가 자동으로 메모리를 해제해 주는 `SoftReference`를 사용하면 좋다.
- 캐시는 언제나 메모리와 성능의 트레이드 오프가 발생하므로, 캐시를 잘 설계하는 것은 쉽지 않다.

.

👉🏻 **무거운 객체를 외부 스코프로 보내기**
- 함수가 한 파일에 다른 함수와 함께 있을 때, 함수를 사용하지 않는다면 지연 초기화(lazy initialization)를 적용하여 프로퍼티를 지연되게 만들어서 무거운 클래스 사용을 유용하게 만들 수 있다.

.

👉🏻 **지연 초기화**

```kotlin
class A {
    val b by lazy { B() }
    val c by lazy { C() }
    val d by lazy { D() }

    //...
}
```

- 이처럼 지연되게 만들면, 첫 번째 호출 때 응답 시간이 굉장히 길것이다.
- 그래서 백엔드 애플리케이션에서 좋지 않을 수 있다.
- 또한, 지연되게 만들면 성능 테스트가 복잡해지는 문제가 있다.
- 따라서, 지연 초기화는 상황에 맞게 사용하자.

.

👉🏻 **기본 자료형 사용하기**

|코틀린의 자료형|자바의 자료형|
|---|---|
|Int|int|
|Int?|Integer|
|List<Int>|List<Integer>|

- 이를 알면 랩한 자료형 대신 기본 자료형을 사용하게 코드를 최적화 할 수 있다.
- 따라서, 굉장히 큰 컬렉션을 처리할 때 차이를 확인할 수 있다.
- 결과적으로, 코드와 라이브러리의 성능이 굉장히 중요한 부분에서만 이를 적용하자.

📖 **정리**

> 이러한 최적화에 큰 변경이 필요하거나, 다른 코드에 문제를 일으킬 수 있다면 최적화를 미루는 것도 방법이다.

## Item 46. 함수 타입 파라미터를 갖는 함수에 inline 한정자 붙이기

`inline` 한정자의 역할은 컴파일 시점에 '함수를 호출하는 부분'을 '함수의 본문'으로 대체하는 것이다.

```kotlin
repeat(10) {
    print(it)
}

// 컴파일
for (index in 0 until 10) {
    print(index)
}
```

`inline` 한정자를 사용할 때 장점
- 타입 아규먼트에 `reified` 한정자를 붙여 사용 가능
- 함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작
- 비지연 리턴 사용 가능

.

👉🏻 **타입 아규먼트를 reified로 사용할 수 있다**
- 단순 호출이 본문으로 대체되므로, reified 한정자를 지정하면, 타입 파라미터를 사용한 부분이 타입 아규먼트로 대체

```kotlin
inline fun <reified T> printTypeName() {
    print(T::class.simpleName)
}

// 사용
printTypeName<Int>()
printTypeName<Char>()
printTypeName<String>()

// 컴파일
print(Int::class.simpleName)
print(Char::class.simpleName)
print(String::class.simpleName)
```

.

👉🏻 **함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작한다**
- 모든 함수는 inline 한정자를 붙이면 조금 더 빠르게 동작한다.
  - 함수 호출과 리턴을 위해 점프하는 과정과 백스택을 추적하는 과정이 없기 때문
  - 그래서 표준 라이브러리에 있는 간단한 함수들에는 대부분 inline 한정자 사용

.

👉🏻 **비지역적 리턴을 사용할 수 있다**
- 함수 리터럴이 컴파일될 때, 함수가 객체로 래핑되어서 문제가 발생할 수 있다.
  - 함수가 다른 클래스에 위치하므로 return을 사용해서 main으로 돌아올 수 없기 때문
  - 함수가 main 함수 내부에 박히기 때문에 인라인 함수는 이런 제한이 없다.

```kotlin
fun  main() {
    repeat(10) {
        print(it)
        return
    }
}
```