# Part 4. 트랜잭션 관리: 사가

마이크로서비스 아키텍처에서 트랜잭션 관리가 어려운 이유와 기존 분산 트랜잭션 관리 방식을 사용할 수 없는 이유에 대한 설명  
그리고 사가로 데이터 일관성을 유지하는 방법을 살펴본 후, 사가를 편성하는 두 가지 기법을 소개
- 중앙 제어 장치 없이 참여자가 각자 서로 이벤트를 교환하는 `코레오그래피`
- 중앙 제어 장치가 참여자가 해야 할 일을 지시하는 방식인 `오케스트레이션`

## 마이크로서비스 아키텍처에서의 트랜잭션 관리

### 분산 트랜잭션의 필요성

단일 데이터베이스를 사용하는 모놀리식 애플리케이션에서는 트랜잭션 관리가 비교적 간단합니다.
- 하지만 마이크로서비스 아키텍처에서는 각 서비스가 자체 데이터베이스를 소유하기 때문에, 하나의 시스템 작업이 여러 서비스에 걸쳐 데이터를 업데이트해야 할 때 데이터 일관성을 유지하는 메커니즘이 필요합니다.
- 예를 들어, createOrder() 작업은 소비자 서비스, 주문 서비스, 주방 서비스, 회계 서비스 등 여러 서비스의 데이터를 읽고 업데이트해야 합니다.

### 분산 트랜잭션의 문제점

전통적인 해결책인 2단계 커밋(Two-Phase Commit, 2PC) 기반의 분산 트랜잭션 메커니즘은 현대 애플리케이션에 적합하지 않습니다.
- 분산 시스템에서 일관성(Consistency), 가용성(Availability), 분할 허용(Partition tolerance) 중 오직 두 가지만 선택할 수 있다는 **CAP 정리(CAP theorem)**에 따르면, 
- 현대 아키텍트들은 **일관성보다 가용성을 선호하는 경향**이 있습니다. 이는 2PC와 같은 강력한 일관성 모델이 가용성을 저해할 수 있기 때문입니다.

### 사가(Saga) 패턴을 통한 데이터 일관성 유지

사가는 분산 트랜잭션을 사용하지 않고 마이크로서비스 아키텍처에서 데이터 일관성을 유지하는 메커니즘입니다.
- 각 사가는 여러 서비스에 걸쳐 데이터를 업데이트해야 하는 시스템 명령에 대해 정의됩니다.
- 사가는 일련의 로컬 트랜잭션으로 구성되며, 각 로컬 트랜잭션은 **단일 서비스 내에서 ACID 트랜잭션 프레임워크를 사용하여 데이터를 업데이트**합니다.
- 하나의 로컬 트랜잭션이 완료되면 다음 로컬 트랜잭션의 실행을 **비동기 메시징을 통해 트리거**합니다. 
  - 이는 참여 서비스 중 **하나가 일시적으로 사용 불가능하더라도 사가 전체가 완료되도록 보장**합니다.

<figure><img src="../../.gitbook/assets/microservices-patterns/4-2.png" alt=""><figcaption></figcaption></figure>

주문 생성 사가는 6개의 로컬 트랜잭션으로 구성
- (1) 주문 서비스: 주문을 APPROVAL_PENDING 상태로 생성
- (2) 소비자 서비스: 주문 가능한 소비자인지 확인
- (3) 주방 서비스: 주문 내역을 확인하고 티켓을 CREATE_PENDING 상태로 생성
- (4) 회계 서비스: 소비자 신용카드를 승인
- (5) 주방 서비스: 티켓 상태를 AWAITING_ACCEPTANCE로 변경
- (6) 주문 서비스: 주문 상태를 APPROVED로 변경
