# Part 4. 트랜잭션 관리: 사가

마이크로서비스 아키텍처에서 트랜잭션 관리가 어려운 이유와 기존 분산 트랜잭션 관리 방식을 사용할 수 없는 이유에 대한 설명  
그리고 사가로 데이터 일관성을 유지하는 방법을 살펴본 후, 사가를 편성하는 두 가지 기법을 소개
- 중앙 제어 장치 없이 참여자가 각자 서로 이벤트를 교환하는 `코레오그래피`
- 중앙 제어 장치가 참여자가 해야 할 일을 지시하는 방식인 `오케스트레이션`

## 마이크로서비스 아키텍처에서의 트랜잭션 관리

### 분산 트랜잭션의 필요성

단일 데이터베이스를 사용하는 모놀리식 애플리케이션에서는 트랜잭션 관리가 비교적 간단합니다.
- 하지만 마이크로서비스 아키텍처에서는 각 서비스가 자체 데이터베이스를 소유하기 때문에, 하나의 시스템 작업이 여러 서비스에 걸쳐 데이터를 업데이트해야 할 때 데이터 일관성을 유지하는 메커니즘이 필요합니다.
- 예를 들어, createOrder() 작업은 소비자 서비스, 주문 서비스, 주방 서비스, 회계 서비스 등 여러 서비스의 데이터를 읽고 업데이트해야 합니다.

### 분산 트랜잭션의 문제점

전통적인 해결책인 2단계 커밋(Two-Phase Commit, 2PC) 기반의 분산 트랜잭션 메커니즘은 현대 애플리케이션에 적합하지 않습니다.
- 분산 시스템에서 일관성(Consistency), 가용성(Availability), 분할 허용(Partition tolerance) 중 오직 두 가지만 선택할 수 있다는 **CAP 정리(CAP theorem)**에 따르면, 
- 현대 아키텍트들은 **일관성보다 가용성을 선호하는 경향**이 있습니다. 이는 2PC와 같은 강력한 일관성 모델이 가용성을 저해할 수 있기 때문입니다.

### 사가(Saga) 패턴을 통한 데이터 일관성 유지

사가는 분산 트랜잭션을 사용하지 않고 마이크로서비스 아키텍처에서 데이터 일관성을 유지하는 메커니즘입니다.
- 각 사가는 여러 서비스에 걸쳐 데이터를 업데이트해야 하는 시스템 명령에 대해 정의됩니다.
- 사가는 일련의 로컬 트랜잭션으로 구성되며, 각 로컬 트랜잭션은 **단일 서비스 내에서 ACID 트랜잭션 프레임워크를 사용하여 데이터를 업데이트**합니다.
- 하나의 로컬 트랜잭션이 완료되면 다음 로컬 트랜잭션의 실행을 **비동기 메시징을 통해 트리거**합니다. 
  - 이는 참여 서비스 중 **하나가 일시적으로 사용 불가능하더라도 사가 전체가 완료되도록 보장**합니다.

<figure><img src="../../.gitbook/assets/microservices-patterns/4-2.png" alt=""><figcaption></figcaption></figure>

주문 생성 사가는 6개의 로컬 트랜잭션으로 구성
- (1) 주문 서비스: 주문을 APPROVAL_PENDING 상태로 생성
- (2) 소비자 서비스: 주문 가능한 소비자인지 확인
- (3) 주방 서비스: 주문 내역을 확인하고 티켓을 CREATE_PENDING 상태로 생성
- (4) 회계 서비스: 소비자 신용카드를 승인
- (5) 주방 서비스: 티켓 상태를 AWAITING_ACCEPTANCE로 변경
- (6) 주문 서비스: 주문 상태를 APPROVED로 변경

**사가는 보상 트랜잭션으로 변경분을 롤백**

- 사가는 ACID 트랜잭션과 달리 **격리성(Isolation) 속성이 부족**합니다.
- 각 로컬 트랜잭션이 변경 사항을 즉시 커밋하기 때문에, 오류 발생 시 **사가의 변경 사항을 되돌리기 위해 보상 트랜잭션**(Compensating Transactions)을 명시적으로 실행해야 합니다.
  - 예를 들어, "주문 생성 사가(Create Order Saga)"는 여러 서비스의 로컬 트랜잭션으로 구성되며, 신용 카드 승인이 실패하면 이전 단계에서 수행된 변경을 되돌리는 보상 트랜잭션을 실행합니다. 
  - 보상 트랜잭션은 순방향 트랜잭션과 역순으로 실행됩니다.
- 사가의 트랜잭션은 세 가지 유형으로 분류될 수 있습니다.
  - **보상 가능한 트랜잭션(Compensatable Transactions)**: 실패할 가능성이 있는 단계 다음에 있는 1~3번째 단계
  - **피봇 트랜잭션(Pivot Transaction)**: 절대로 실패하지 않는 단계 다음에 있는 4단계
  - **재시도 가능한 트랜잭션(Retriable Transactions)**: 항상 성공하는 5~6단계

<figure><img src="../../.gitbook/assets/microservices-patterns/table-4-1.png" alt=""><figcaption></figcaption></figure>

소비자의 신용카드 승인이 실패하면 실행되는 보상 트랜잭션 순서
- (1) 주문 서비스: 주문을 APPROVAL_PENDING 상태로 생성
- (2) 소비자 서비스: 주문 가능한 소비자인지 확인
- (3) 주방 서비스: 주문 내역을 확인하고 티켓을 CREATE_PENDING 상태로 생성
- (4) 회계 서비스: 소비자의 신용카드 승인 요청이 거부
- (5) 주방 서비스: 티켓 상태를 CREATE_REJECTED로 변경
- (6) 주문 서비스: 주문 상태를 REJECTED로 변경

## 사가 편성

사가는 분산 트랜잭션 대신 여러 서비스에 걸쳐 데이터를 업데이트하는 일련의 로컬 트랜잭션으로 구성됩니다.  
사가 조정에는 크게 두 가지 방식이 있습니다
- **코레오그래피(Choreography)**: 의사 결정과 순서화를 사가 참여자에게 맡긴다. 사가 참여자는 주로 이벤트 교환방식으로 통신
- **오케스트레이션(Orchestration)**: 사가 편성 로직을 사가 오케스트레이터에 중앙화. 사가 오케스트레이터는 사가 참여자에게 커맨드 메시지를 보내 수행할 작업을 지시












