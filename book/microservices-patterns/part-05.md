# Part 5. 비즈니스 로직 설계

마이크로서비스 아키텍처에서 비즈니스 로직을 개발하는 것은 다음과 같은 두 가지 주요 과제 때문에 더욱 어렵습니다:
* **서비스 경계를 넘나드는 객체 참조 제거**: 
  * 일반적인 도메인 모델은 상호 연결된 클래스들의 복잡한 웹이지만, 마이크로서비스 아키텍처에서는 클래스들이 여러 서비스에 분산되어 있어 서비스 경계를 넘어선 객체 참조를 없애야 합니다.
* **분산 트랜잭션 관리**: 
  * 마이크로서비스 아키텍처의 트랜잭션 관리 제약 조건 내에서 작동하는 비즈니스 로직을 설계해야 합니다. 
  * 서비스 내에서는 ACID 트랜잭션을 사용할 수 있지만, **서비스 간 데이터 일관성을 유지하기 위해서는 사가(Saga) 패턴을 사용**해야 합니다.

이 장에서는 이러한 문제들을 해결하기 위해 다음과 같은 비즈니스 로직 조직화 패턴들을 다룹니다:
* **트랜잭션 스크립트(Transaction Script) 패턴**
* **도메인 모델(Domain Model) 패턴**
* **DDD 집계(Aggregate) 패턴**: 
  * 서비스의 비즈니스 로직을 집합(aggregate)으로 구조화하여 서비스 간 객체 참조 문제를 피하고, 
  * 단일 트랜잭션 내에서 단일 집합만 생성 또는 업데이트하도록 하여 마이크로서비스 트랜잭션 모델의 제약 조건에 부합하게 합니다.
* **도메인 이벤트(Domain Event) 패턴**: 서비스가 이벤트를 발행하는 것이 왜 유용한지 설명합니다.

## 비즈니스 로직 구성 패턴

이 섹션에서는 **서비스의 일반적인 아키텍처와 비즈니스 로직을 조직하는 두 가지 주요 패턴**인 `트랜잭션 스크립트 패턴`과 `도메인 모델 패턴`에 대해 설명합니다.

### 서비스 아키텍처와 어댑터

전형적인 서비스의 아키텍처는 **헥사고날 아키텍처(Hexagonal architecture)**를 따르며, **비즈니스 로직이 핵심(core)**을 이룹니다.  
비즈니스 로직 주변에는 인바운드(inbound) 어댑터와 아웃바운드(outbound) 어댑터가 있습니다.

<figure><img src="../../.gitbook/assets/microservices-patterns/5-1.png" alt=""><figcaption></figcaption></figure>

* **인바운드 어댑터**: 클라이언트의 요청을 처리하고 `비즈니스 로직을 호출`합니다.
  *   **REST API 어댑터**: REST API를 구현하여 비즈니스 로직을 호출하는 인바운드 어댑터입니다.
  *   **OrderCommandHandlers**: 메시지 채널에서 명령 메시지(command messages)를 소비하고 비즈니스 로직을 호출하는 인바운드 어댑터입니다.
* **아웃바운드 어댑터**: 비즈니스 로직에 의해 호출되며 `다른 서비스나 애플리케이션을 호출`합니다.
  *   **데이터베이스 어댑터(Database Adapter)**: 비즈니스 로직에 의해 호출되어 데이터베이스에 접근합니다.
  *   **도메인 이벤트 발행 어댑터(Domain Event Publishing Adapter)**: 메시지 브로커에 이벤트를 발행합니다.

### 비즈니스 로직 조직화 패턴

비즈니스 로직을 개발할 때 중요한 결정은 객체 지향 접근 방식 또는 절차적(procedural) 접근 방식을 사용할지 여부입니다. 여기에는 두 가지 주요 패턴이 있습니다:

**트랜잭션 스크립트(Transaction Script) 패턴**

* **개념**: **각 요청/시스템 작업을 처리하기 위한 절차적 코드로 비즈니스 로직을 구성**합니다. 
  * 객체 지향 설계 없이, 프레젠테이션 계층의 각 요청에 대해 트랜잭션 스크립트라는 메서드를 작성합니다.
* **특징**: 행동을 구현하는 클래스(예: `OrderService`)와 상태를 저장하는 클래스(예: `Order` 데이터 객체)가 분리됩니다. 
  * `OrderService`와 같은 서비스 클래스는 각 요청에 대한 하나의 메서드를 가지며, 이 메서드가 비즈니스 로직을 구현하고 데이터 접근 객체(DAO)를 통해 데이터베이스에 접근합니다.
  * 데이터 객체(예: `Order` 클래스)는 동작이 거의 없는 순수한 데이터입니다.
* **장점**: 간단한 비즈니스 로직에 적합하며 구현이 간단합니다.
* **단점**: 비즈니스 로직이 복잡해지면 유지보수가 어려워질 수 있으며, 코드가 "악몽"이 될 수 있습니다.

**도메인 모델(Domain Model) 패턴**

* **개념**: **상태와 행동을 모두 가지는 클래스들로 구성된 객체 모델(object model)로 비즈니스 로직을 구성**합니다. 
  * 이 클래스들은 문제 도메인의 개념에 직접적으로 매핑됩니다.
* **특징**: `OrderService`와 같은 서비스 클래스는 여전히 각 요청에 대한 메서드를 가지지만, 이 메서드들은 **영속적인 도메인 객체(persistent domain objects)에게 대부분의 비즈니스 로직을 위임**합니다. 
  * 예를 들어, `Order` 클래스는 상태와 행동을 모두 가지며, 상태는 비공개(private)이며 메서드를 통해서만 접근 가능합니다.
* **장점**:
  * **이해 및 유지보수 용이**: 모든 것을 수행하는 하나의 큰 클래스 대신, 각각 작은 책임을 가진 여러 작은 클래스로 구성되어 이해하고 유지보수하기 쉽습니다.
  * **테스트 용이**: 각 클래스를 독립적으로 테스트할 수 있습니다.
  * **확장 용이**: 전략 패턴, 템플릿 메서드 패턴과 같은 잘 알려진 디자인 패턴을 사용하여 코드 수정 없이 확장이 용이합니다.
* **한계**: 이 패턴은 잘 작동하지만, 특히 마이크로서비스 아키텍처에서는 몇 가지 문제가 있어 **DDD(도메인 주도 설계)의 정교화된 접근 방식**이 필요합니다.

이러한 패턴들을 이해하는 것은 마이크로서비스 환경에서 효과적인 비즈니스 로직을 설계하는 데 필수적입니다.

## 도메인 모델 설계: DDD 애그리거트 패턴

마이크로서비스 아키텍처에서 복잡한 비즈니스 로직을 효과적으로 설계하고 관리하기 위한 핵심 패턴인 DDD 집계(Aggregate) 패턴의 개념, 중요성 및 규칙

**불분명한 경계 문제**

* 전통적인 객체 지향 도메인 모델은 종종 비즈니스 객체(예: `Order`)의 명시적인 경계가 부족하여 **개념적 모호성**을 야기하고, 특히 객체 업데이트 시 문제를 발생시킵니다.
* 비즈니스 객체는 항상 지켜져야 하는 **불변식(invariants)**, 즉 비즈니스 규칙을 가집니다 (예: 주문의 최소 금액).
* 명시적인 경계가 없는 경우, 동시에 여러 사용자가 부분적으로 비즈니스 객체를 업데이트할 때 (예: 두 소비자가 동시에 주문의 다른 항목을 수정하여 총 주문 금액이 의도치 않게 최소 금액 아래로 떨어지는 경우) **불변식이 위반될 수 있습니다**. 
  * 이는 애플리케이션이 각 개별 업데이트 시에는 불변식을 확인했더라도 전체적으로는 유효하지 않은 상태가 될 수 있음을 보여줍니다.

.

**애그리거트는 경계가 분명하다**

* **집계(Aggregate)**는 **단위로 취급될 수 있는 도메인 객체들의 클러스터**입니다. 
  * 이는 **루트 엔티티**와 하나 이상의 다른 엔티티 및 값 객체(value objects)로 구성됩니다.
* 예를 들어, `Order` 집계는 `Order` 엔티티와 `OrderLineItem`, `DeliveryAddress`, `PaymentInformation`과 같은 값 객체들로 구성됩니다.
* 집계는 도메인 모델을 더 작은 조각으로 분해하여 개별적으로 이해하기 쉽게 만들고, 로드(load), 업데이트(update), 삭제(delete)와 같은 **작업의 범위를 명확하게 합니다**.
* 집계는 전체적으로 업데이트되며, 불변식을 강제하는 **집계 루트(aggregate root)**를 통해 동시성(concurrency)을 처리합니다 (예: 버전 번호 사용).

경계가 분명한 애그리거트로 구성된 도메인 모델

<figure><img src="../../.gitbook/assets/microservices-patterns/5-5.png" alt=""><figcaption></figcaption></figure>

.

**애그리거트 규칙**

* DDD는 집계가 지켜야 할 일련의 규칙을 정의하여 자가 포함적인 단위로서 불변식을 강제할 수 있도록 합니다.
* **규칙 #1: 오직 집계 루트만 참조**: 
  * 집계 외부의 클래스는 오직 집계 루트 엔티티만 참조할 수 있습니다. 
  * 클라이언트는 집계 루트에 메서드를 호출하여 집계를 업데이트해야 합니다. 
  * 이는 집계가 불변식을 강제하도록 보장합니다.
* **규칙 #2: 집계 간 참조는 기본 키를 사용해야 함**: 
  * 집계들은 객체 참조 대신 **식별자(기본 키)**를 통해 서로를 참조해야 합니다. 
  * 예를 들어, `Order`는 `Consumer` 객체에 대한 참조 대신 `consumerId`를 사용합니다.
  * 이 접근 방식은 **집계 간의 느슨한 결합**을 보장하고, 서비스 경계를 넘는 객체 참조 문제를 방지하여 마이크로서비스 아키텍처에 매우 중요합니다. 
  * 또한, 영속화를 단순화하고 NoSQL 데이터베이스에 더 적합하며 지연 로딩(lazy loading) 문제를 제거합니다.
* **규칙 #3: 하나의 트랜잭션은 하나의 집계만 생성 또는 업데이트**: 
  * 단일 ACID 트랜잭션은 오직 하나의 집계만 생성하거나 업데이트할 수 있습니다.
  * 이는 마이크로서비스 아키텍처의 트랜잭션 모델 제약 조건과 완벽하게 일치하며, **트랜잭션이 서비스 내에 국한되도록 보장합니다**.
  * 여러 집계를 생성하거나 업데이트해야 하는 작업의 경우, **사가(Saga) 패턴**을 사용해야 합니다. 
  * 사가의 각 단계는 정확히 하나의 집계를 생성하거나 업데이트합니다.


## 도메인 이벤트 발행

## 주방 서비스 비즈니스 로직

## 주문 서비스 비즈니스 로직

## 마치며









