---
description: 대규모 시스템 설계 기초 2nd 12장을 요약한 내용입니다.
---

결제 플랫폼은 일반적으로 고객에게 전자 지갑 서비스를 제공하여 고객으로 하여금 지갑에 돈을 넣어 두고 필요할 때 사용할 수 있도록 한다.

<figure><img src="../../.gitbook/assets/system-design-interview-2nd/12.1.png" alt=""><figcaption></figcaption></figure>

전자 지갑은 결제 기능뿐만 아니라 페이팔은 같은 플랫폼의 다른 사용자 지갑으로 직접 송금을 지원한다.
- 전자 지갑 간 이체는 은행 간 이체보다 빠르며, 일반적으로 추가 수수료를 부과하지 않느다.

# 1단계: 문제 이해 및 설계 범위 확정
 
설계할 전자 지갑
- 전자 지갑 간 이체
- 1,000,000TPS
- 99.99%의 안정성
- 트랜잭션
- 재현성

# 2단계: 개략적 설계안 제시 및 동의 구하기

## API 설계

**API**

|API|기능|
|:---|:---|
|POST /v1/wallet/balance_transfer|한 지갑에서 다른 지갑으로 자금 이체|

**요청 인자**

|필드|설명|자료형|
|---|---|---|
|from_account|자금을 인출할 계좌|string|
|to_account|자금을 이체할 계좌|string|
|amount|이체할 금액|string|
|currency|통화 단위|string(ISO 4217)|
|transaction_id|중복 제거에 사용할 ID|uuid|

응답 본문 사례:

```json
{
    "status": "success"
    "transaction_id": "01589980-2434-33dx-1532-1423gb420530"
}
```

## 인메모리 샤딩

모든 사용자 계정의 잔액을 유지하는 지갑 애플리케이션은 `<사용자, 잔액>` 관계를 나타내기 좋은 자료구조로 해시 테이블(Map, Key-value 저장소)을 사용한다.

인메모리 저장소로 인기 있는 선택지는 레디스.
- 그러나 레디스 노드 한 대로 100만 TPS 처리는 벅차다.
- 클러스터를 구성하고 사용자 계정을 모든 노드에 균등하게 분산시켜야 한다.
- 이 절차를 파티셔닝 또는 샤딩이라고 한다.

키-값 데이터를 n개의 파티션에 고르게 분배하려면 키의 해시 값을 계산하고, 이를 파티션의 수 n으로 나누는 것이 한 가지 방법
- 그 결과로 얻은 나머지 값이 데이터를 저장할 파티션 번호

```java
String accountID = "A";
Int partitionNumber = 7;
Int myPartition = accountID.hashCode() % partitionNumber;
```

모든 레디스 노드의 파티션 수 및 주소는 한군데 저장해 두는데, 높은 가용성을 보장하는 설정 정보 전문 저장소 주키퍼를 이 용도로 사용하면 좋다.

지갑 서비스의 중요한 역할

1. 이체 명령의 수신
2. 이체 명령의 유효성 검증
3. 명령이 유효한 것으로 확인되면 이체에 관계된 두 계정의 잔액 갱신. (이 두 계정은 서로 다른 레디스 노드에 있을 수 있음)

**메모리 기반 솔루션**

<figure><img src="../../.gitbook/assets/system-design-interview-2nd/12.3.png" alt=""><figcaption></figcaption></figure>

## 분산 트랜잭션

### 데이터베이스 샤딩

서로 다른 두 개 저장소 노드를 갱신하는 연산을 원자적으로 수행하기 위한 방법

1단계. 각 레디스 노드를 트랜잭션을 지원하는 관계형 데이터베이스 노드로 교체하는 것
- A, B, C의 잔액 정보가 레디스 노드가 아닌 3개의 관계형 데이터베이스 노드로 분산

<figure><img src="../../.gitbook/assets/system-design-interview-2nd/12.4.png" alt=""><figcaption></figcaption></figure>

### 분산 트랜잭션: 2단계 커밋

분산 시스템에서 한 트랜잭션에는 여러 노드의 프로세스가 관여할 수 있다.
- 분산 트랜잭션은 이들 프로세스를 원자적인 하나의 트랜잭션으로 묶는 방안
- 저수준 방안
  - 데이터베이스 자체에 의존하는 방안
  - 일반적으로 사용되는 2단계 커밋 알고리즘
  
  <figure><img src="../../.gitbook/assets/system-design-interview-2nd/12.5.png" alt=""><figcaption></figcaption></figure>

  - 저수준 방안인 이유는, 준비 단계 실행을 위해 데이터베이스 스랜잭션 실행 방식을 변경해야 하기 때문
  - 다른 노드의 메시지를 기다리는 동안 락이 오랫동안 잠긴 상태로 남고, 조정자가 SPOF(Single-Point-Of-Failure, 단일 장애 지점)이 될 수 있다.

  <figure><img src="../../.gitbook/assets/system-design-interview-2nd/12.6.png" alt=""><figcaption></figcaption></figure>

### 분산 트랜잭션: TC/C

TC/C(시도-확정/취소, Try-Confirm/Cancel)는 두 단계로 구성된 보상 트랜잭션

1. 조정자는 모든 DB에 트랜잭션에 필요한 자원 예약을 요청
2. 조정자는 모든 DB로부터 회신을 받음
   - 모두 '예'라고 응답하면 조정자는 모든 DB에 작업 확인을 요청. 이것이 '시도-확정(Try-Confirm)' 절차
   - 어느 하나라도 '아니오'라고 응답하면 조정자는 모든 DB에 작업 취소를 요청하며, 이것이 '시도-취소(Try-Cancel)' 절차

#### ✅ TC/C 사례

계좌 A에서 계좌 C로 1달러 이체한다는 가정

<figure><img src="../../.gitbook/assets/system-design-interview-2nd/12.2.png" alt=""><figcaption></figcaption></figure>

- TC/C의 조정자: 지갑 서비스
- 계정 A의 잔액: 1달러
- 계정 C의 잔액: 0달러

**첫 번째 단계: 시도**

- 시도 단계에서는 조정자 역할을 하는 지갑 서비스가 두 개의 트랜잭션 명령을 두 데이터베이스로 전송
  - (1) 조정자는 계정 A가 포함된 DB에 A의 잔액을 1달러 감소시키는 트랜잭션을 시작
  - (2) 조정자는 계정 C가 포함된 DB에 아무 작업도 하지 않음.

  <figure><img src="../../.gitbook/assets/system-design-interview-2nd/12.7.png" alt=""><figcaption></figcaption></figure>

**두 번째 단계: 확정**
- 두 DB가 모두 예라고 응답하면 지갑 서비스는 확정 단계를 시작
  - 계정 A의 잔액은 이미 첫 번째 단계에서 갱신
  - 환인 단계에서 지갑 서비스는 계정 C의 잔액에 $1를 추가

  <figure><img src="../../.gitbook/assets/system-design-interview-2nd/12.8.png" alt=""><figcaption></figcaption></figure>

# 3단계: 상세 설계

# 4단계: 마무리

# 요약
