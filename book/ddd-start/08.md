---
description: 도메인 주도 개발 시작하기 8장을 요약한 내용입니다.
---

# 애그리거트 트랜잭션 관리

트랜잭션마다 리포지터리는 새로운 애그리거트 객체를 생성하므로 운영자 스레드와 고객 스레드는 같은 주문 애그리거트를 나타내는 다른 객체를 구하게 된다.

운영자 스레드와 고객 스레드는 **개념적으로 동일한 애그리거트지만 물리적으로 서로 다른 애그리거트 객체를 사용**한다.
- 운영자 스레드가 주문 애그리거트 객체를 배송 상태로 변경하더라도 고객 스레드가 사용하는 주문 애그리거트 객체에는 영향을 주지 않는다.
- 두 스레드는 각각 트랜잭션을 커밋할 때 수정한 내용을 DB에 반영한다.
- 운영자는 기존 배송지 정보를 이용해서 배송 상태로 변경했는데, 그 사이 고객은 배송지 정보를 변경했다는 문제가 발생하여 **애그리거트의 일관성이 꺠지게 된다.**

<figure><img src="../../.gitbook/assets/ddd-start/aggregate-transaction.png" alt=""><figcaption></figcaption></figure>

일관성이 깨지는 문제가 발생하지 않도록 하려면 다음 두 가지 중 하나를 해야 한다.
- 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안, 고객이 애그리거트를 수정하지 못 하도록 막기
- 운영자가 배송지 정보를 조회한 이후 고객이 정보를 변경하면, 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 하기

이 두 가지는 애그리거트 자체의 트랜잭션과 관련이 있는데, DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요하다. 대표적으로 애그리거트 자체 트랜잭션 처리 방식은 두 가지 방식이 있다.
- 선점 잠금(Pessimistic Lock)
- 비선점 잠금(Optimistic Lock)

# 선점 잠금

선점 잠금(Pessimistic Lock)은 **먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식**이다.

<figure><img src="../../.gitbook/assets/ddd-start/pessimistic-lock.png" alt=""><figcaption></figcaption></figure>

선점 잠금 동작 방식
- 스레드1이 선점 잠금 방식으로 애그리거트를 구한 뒤 이어서 스레드2가 같은 애그리거트를 구함
- 스레드2는 스레드1이 애그리거트에 대한 잠금을 해제할 때까지 블로킹
- 스레드1이 애그리거트를 수정하고 트랜잭션을 커밋하면 잠금 해제
- 대기하고 있던 스레드2가 애그리거트에 접근
- 스레드1이 트랜잭션을 커밋한 뒤에 스레드2가 애그리거트를 구하게 되므로 스레드2는 스레드1이 수정한 애그리거트의 내용을 조회

선점 잠금 방식을 통해 **동시에 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소**할 수 있다.

선점 잠금은 보통 DBMS가 제공하는 **행단위 잠금을 사용해서 구현**
- 오라클을 비롯한 다수의 DBMS가 `for update` 같은 쿼리를 사용해서 특정 레코드에 한 커넥션만 접근할 수 있는 잠금창지를 제공

`JPA EntityManager`는 `LockModeType`을 인자로 받는 `find()` 메서드를 제공
- `LockModeType.PESSIMISTIC_WRITE`를 값으로 전달하면 해당 엔티티와 매핑된 테이블을 이용해서 선점 잠금 방식 적용 가능

```java
Order order = entityManager.find(
    Order.class, orderNo, LockModeType.PESSIMISTIC_WRITE);
```

JPA 프로바이더와 DBMS에 따라 잠금 모드 구현이 다르다.
- 하이버네이트의 경우 `PESSIMISTIC_WRITE`를 잠금 모드로 사용하면 `for update` 쿼리를 이용해서 선점 잠금을 구현
- Spring Data JPA는 `@Lock`을 사용해서 잠금 모드를 지정

```java
public interface MemberRepository extends Repository<Member, MemberId> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @QueryHints({
            @QueryHint(name = "javax.persistence.lock.timeout", value = "3000")
    })
    @Query("select m from Member m where m.id = :id")
    Optional<Member> findByIdForUpdate(@Param("id") MemberId memberId);
    ...
}
```

## 선점 잠금과 교착 상태

선점 잠금 기능을 사용할 경우 **잠금 순서에 따른 교착 상태(deadlock)가 발생하지 않도록 주의**가 필요하다. 다음과 같은 순서로 두 스레드가 잠금 시도를 한다고 가정해 보자.

1. 스레드1: A 애그리거트에 대한 선점 잠금 구함
2. 스레드2: B 애그리거트에 대한 선점 잠금 구함
3. 스레드1: B 애그리거트에 대한 선점 잠금 시도
4. 스레드2: A 애그리거트에 대한 선점 잠금 시도

이 순수에 따르면 스레드1은 영원히 B 애그리거트에 대한 선점 잠금을 구할 수 없다.
- 스레드2가 B 애그리거트에 대한 잠금을 이미 선점하고 있기 때문.
- 동일하게 스레드2도 A 애그리거트에 대한 잠금을 구할 수 없다.
- 두 스레드는 상대방 스레드가 먼저 선점한 잠금을 구할 수 없어 더 이상 다음 단계를 진행할 수 없다.
- 즉, 스레드1, 스레드2는 **교착 생태(deadlock)**에 빠지게 된다.

선점 잠금에 따른 교착 상태는 **상대적으로 사용자 수가 많을 때 발생할 가능성이 높고, 사용자 수가 많아지면 교착 상태에 빠지는 스레드는 더 빠르게 증가**한다.
- 더 많은 스레드가 교착 상태에 빠질수록 시스템은 아무것도 할 수 없는 상태가 된다.

이러한 문제를 해결하려면 **잠금을 구할 때 최대 대기시간을 지정**해야 한다.
- JPA에서 선점 잠금을 시도할 때 최대 대기 시간을 지정하려면 힌트를 사용한다.

```java
Map<String, Object> hints = new HashMap<>();
hints.put("javax.persistence.lock.timeout", 2000);
Order order = entityManager.find(
    Order.class, orderNo, LockModeType.PESSIMISTIC_WRITE);
```

JPA의 `javax.persistence.lock.timeout` 힌트는 잠금을 구하는 대기 시간을 밀리초 단위로 지정한다.
- 지정한 시간 이내 잠금을 구하지 못하면 익셉션 발생
- DBMS에 따라 힌트가 적용되지 않을 수 있으니 주의 필요
- 힌트 이용 시 사용 중인 DBMS가 관련 기능을 지원하는지 확인 필요

Spring Data JPA는 @QueryHints를 사용해서 쿼리 힌트 지정 가능

```java
public interface MemberRepository extends Repository<Member, MemberId> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @QueryHints({
            @QueryHint(name = "javax.persistence.lock.timeout", value = "3000")
    })
    @Query("select m from Member m where m.id = :id")
    Optional<Member> findByIdForUpdate(@Param("id") MemberId memberId);
    ...
}
```

> DBMS에 따라 교착 상태에 빠진 커넥션을 처리하는 방식이 다르다.
>
> 선점 잠금을 사용하려면 사용하는 DBMS에 대해 JPA가 어떤 식으로 대기 시간을 처리하는지 반드시 확인하자.












# 09.도메인 모델과 바운디드 컨텍스트

# 10.이벤트

# 11.CQRS