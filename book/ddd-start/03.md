# Chapter 3. 애그리거트

## 애그리거트

개별 객체 수준에서 모델을 바라보면 상위 수준에서 관계를 파악하기 어렵다. 하지만, 상위 수준에서 모델을 정리하면 도메인 모델의 복잡한 관계를 이해하는 데 도움이 된다.

애그리거트는 **관련된 객체를 하나의 군으로** 묶어 준다. 수많은 객체를 애그리거트로 묶어서 바라보면 **상위 수준에서 도메인 모델 간의 관계를 파악**할 수 있다.

애그리거트는 복잡한 모델을 관리하는 기준을 제공.

<figure><img src="../../.gitbook/assets/ddd-start/aggregate.jpg" alt=""><figcaption></figcaption></figure>

한 애그리거트에 속한 객체는 **유사**하거나 **동일한 라이프 사이클**을 갖는다.

애그리거트는 **독립된 객체 군**이며 각 애그리거트는 **자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다**.

상품이 리뷰를 갖는 것으로 생각할 수 있지만, 상품과 리뷰는 **함께 생성되거나 변경되지 않고, 변경 주체도 다르기 때문에** 서로 다른 애그리거트에 속한다.

## 애그리거트 루트

애그리거트에 속한 **모든 객체가 일관된 상태를 유지**하려면 애그리거트 전체를 **관리할 주체**가 필요하다.

이 책임을 지는 것이 바로 애그리거트의 **루트 엔티티**이다.

- 주문 애그리거트에서 루트 역할을 하는 엔티티는 `Order`.
- 주문 애그리거트에 속한 모델은 `Order`에 직/간접적으로 속한다.

**도메인 규칙과 일관성**

애그리거트 루트의 핵심 역할은 **애그리거트의 일관성이 깨지지 않도록 하는 것**이다.
- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안 된다.

불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 습관적으로 적용해야 할 것이 있다.
- 단순히 필드를 변경하는 set 메서드를 공개 범위로 만들지 않기
  - 대신 의미가 드러나는 메서드를 사용해서 구현하자(ex. cancel, changePassword)
- 밸류 타입은 불변으로 구현하기
  - 밸류 객체의 값을 변경하려면 새로운 밸류 객체를 할당하자
  - 불변으로 구현할 수 없다면, 밸류의 변경 기능을 package/protected 범위로 한정해서 외부 실행 불가하도록 제한하자


# Chapter 4. 리포지터리와 모델

# Chapter 5. 스피링 데이터 JPA

# Chapter 6. 응용 서비스와 표현 영역

# Chapter 7. 도메인 서비스

# Chapter 8. 애그러기트 트랜잭션

# Chapter 9. 도메인 모델과 바운디드 컨텍스트

# Chapter 10. 이벤트

# Chapter 11. CQRS