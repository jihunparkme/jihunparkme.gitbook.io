# Chapter 4. 리포지터리와 모델 구현

## JPA를 이용한 리포지터리 구현

### 모듈 위치

**리포지터리 인터페이스는 애그리거트와 같은 도메인 영역**에 속하고, **리포지터리를 구현한 클래스는 인프라스트럭처 영역**에 속한다.
- 기능하면 리토지터리 구현 클래스를 인프라스트럭처 영역에 위치 시켜서 인프라스트럭처에 대한 의존을 낮추자.

### 리포지터리 기본 기능 구현

리포지터리 인터페이스는 **애그리거트 루트를 기준**으로 작성하자.

```java
public interface OrderRepository {
    Optional<Order> findById(OrderNo no);
    void save(Order order);
    List<Order> findByOrdererId(String ordererId, int startRow, int size);
}
```

애그리거트 조회는 ID 외에도 JPA `Criteria`, `JPQL`을 사용할 수도 있다.

> 사용자가 삭제 기능을 실행할 때 데이터를 바로 삭제하기보다는 삭제 플래그를 사용해서 데이터를 화면에 보여줄지 여부를 결정하는 방식으로 구현하자.
>
> 관리자 기능에서 삭제 데이터 조회를 해야 하거나 데이터 원복을 위해 일정 기간 보관해야 할 경우도 있다.

## Spring Data JPA를 이용한 리포지터리 구현

스프링과 JPA를 함께 적용할 때는 Spring Data JPA를 사용한다.
- 지정한 규칙에 맞게 리포지터리 인터페이스를 정의하면 리포지터리를 구현한 객체를 알아서 만들어 스프링 빈으로 등록

아래 규칙에 따라 작성한 인터페이스를 찾아서 인터페이스를 구현한 스프링 빈 객체를 자동 등록
- `org.springframework.data.repository.Repository<T, ID>` 인터페이스 상속
- T는 엔티티 타입, ID는 식별자 타입

Spring Data JPA 사용을 위해 지정한 규칙에 맞게 메서드를 작성해야 한다.
- [JPA Query Methods](https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html#jpa.query-methods.query-creation)

## 매핑 구현

### 엔티티와 밸류 기본 매핑 구현

애그리거트와 JPA 매핑을 위한 기본 규칙
- 애그리거트 루트는 엔티티이므로 `@Entity` 매핑 설정

```java
@Entity
@Table(name = "purchase_order")
public class Order {
    @EmbeddedId
    private OrderNo number;

    @Embedded
    private Orderer orderer;

    @Embedded
    private ShippingInfo shippingInfo;
    ...
```

한 테이블에 엔티티와 밸류 데이터가 같이 있다면
- 밸류는 `@Embeddable`로 매핑 설정
- 밸류 타입 프로퍼티는 `@Embedded`로 매핑 설정

```java
@Embeddable
public class Orderer {

    @Embedded
    @AttributeOverrides( // 컬럼명과 실제 컬럼명이 다르므로 매핑 컬럼 변경        
        @AttributeOverride(name = "id", column = @Column(name = "orderer_id"))
    )
    private MemberId memberId; // Member 애그리거트를 ID로 참조

    @Column(name = "orderer_name")
    private String name;
    ...
}

...

@Embeddable
public class MemberId implements Serializable {
    @Column(name = "member_id")
    private String id;
}

@Embeddable
public class ShippingInfo {
    @Embedded
    @AttributeOverrides({ // 매핑 설정과 다른 컬럼 이름을 사용하기 위한 설정의 다른 예
            @AttributeOverride(name = "zipCode", column = @Column(name = "shipping_zip_code")),
            @AttributeOverride(name = "address1", column = @Column(name = "shipping_addr1")),
            @AttributeOverride(name = "address2", column = @Column(name = "shipping_addr2"))
    })
    private Address address;

    @Column(name = "shipping_message")
    private String message;

    @Embedded
    private Receiver receiver;
    ...
}
```

### 기본 생성자

앤티티와 밸류의 생성자는 객체를 생성할 때 **필요한 것을 전달** 받는다.
- 불변 타입이면 생성 시점에 필요한 값을 모두 전달받고, 값을 변경하는 set 메서드는 미제공
- 기본 생성자는 불필요

하지만, JPA에서 `@Entity`, `@Embeddable`로 클래스를 매핑하려면 기본 생성자를 제공해야 한다.
- DB에서 데이터를 읽어와 매핑 객체를 생성할 때 기본 생성자 사용

다른 코드에서 기본 생성자를 사용하지 못 하도록 protected 선언을 해주자.
- 기본 생성자는 JPA 프로바이더가 객체 생성 시에만 사용

```java
@Embeddable
public class Receiver {
    @Column(name = "receiver_name")
    private String name;

    @Column(name = "receiver_phone")
    private String phone;

    protected Receiver() {
    }

    public Receiver(String name, String phone) {
        this.name = name;
        this.phone = phone;
    }
    ...
}
```

### 필드 접근 방식 사용

객체가 제공할 기능 중심으로 엔티티를 구현하도록 유도하려면, JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택해서 불필요한 get/set 메서드를 구현하지 않도록 하자.
- 하이버네이트는 `@Access`로 접근 방식을 지정하지 않으면 `@Id`, `@Embeddable` 위치에 따라 접근 방식을 결정
- 필드에 위치하면 필드 접근 방식을 선택
- get 메서드에 위치하면 메서드 접근 방식 선택

```java
@Entity
@Table(name = "purchase_order")
@Access(AccessType.FIELD)
public class Order {

    @EmbeddedId
    private OrderNo number;

    @Column(name = "state")
    @Enumerated(EnumType.STRING)
    private OrderState state;
    ...
}
```

### AttributeConverter를 이용한 밸류 매핑 처리

AttributeConverter는 다음과 같이 밸류 타입과 컬럼 데이터 간의 변환을 처리하기 위한 기능을 정의
- X는 밸류 타입
- Y는 DB 타입

```java
package javax.persistence;

public interface AttributeConverter<X, Y> {
    Y convertToDatabaseColumn(X var1); // 밸류 타입을 DB 컬럼 값으로 변환
    X convertToEntityAttribute(Y var1); // DB 컬럼 값을 밸류로 변환
}
```

Money 밸류 타입을 위한 AttributeConverter 예시
- AttributeConverter 구현 클래스는 `@Converter` 적용
- `autuApply = true` 지정 시 모델에 출현하는 모든 Money 타입의 프로퍼티에 대해 AttributeConverter 자동 적용
- `autuApply = false`(default) 지정 시 프로퍼티 값 변환 시 사용할 컨버터를 직접 지정

```java
@Converter(autuApply = true)
public class MoneyConverter implements AttributeConverter<Money, Integer> {

    @Override
    public Integer convertToDatabaseColumn(Money money) {
        return money == null ? null : money.getValue();
    }

    @Override
    public Money convertToEntityAttribute(Integer value) {
        return value == null ? null : new Money(value);
    }
}

...

/**
 * autuApply = false 일 경우
 */
@Column(name = "total_amounts")
@Convert(converter = MoneyConverter.class)
private Money totalAmounts;
```

### 밸류 컬렉션: 별도 테이블 매핑

밸류 컬렉션을 별도 테이블로 매핑할 때는 `@ElementCollection`, `@CollectionTable`을 함께 사용
- `@OrderColumn`을 이용해서 지정한 컬럼에 리스트의 인덱스 값을 저장.(List 타입 자체가 인덱스를 가지고 있다)
- `@CollectionTable`은 밸류를 저장할 테이블 지정(name: 테이블 이름, joinColumns: 외부키로 사용할 컬럼)

```java
@Entity
@Table(name = "purchase_order")
public class Order {

    @EmbeddedId
    private OrderNo number;
        
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "order_line", joinColumns = @JoinColumn(name = "order_number"))
    @OrderColumn(name = "line_idx")
    private List<OrderLine> orderLines;
    ...
}

...

@Embeddable
public class OrderLine {
    @Embedded
    private ProductId productId;

    @Convert(converter = MoneyConverter.class)
    @Column(name = "price")
    private Money price;

    @Column(name = "quantity")
    private int quantity;
    ...
}
```

### 밸류 컬렉션: 한 개 컬럼 매핑

밸류 컬렉션을 별도 테이블이 아닌 한 개 컬럼에 저장해야 할 경우
- 도메인 모델에는 이메일 주소 목록을 Set으로 보관하고, DB에는 한 개의 컬럼에 콤마로 구분해서 저장

```java
public class EmailSet {
    private Set<Email> emails = new HashSet<>();

    public EmailSet(Set<Email> emails) {
        this.emails.addAll(emails);
    }

    public Set<Email> getEmails() {
        return Collections.unmodifiableSet(emails);
    }
}

...

public class EmailSetConverter implements AttributeConverter<EmailSet, String> {
    @Override
    public String convertToDatabaseColumn(EmailSet attribute) {
        if (attribute == null) return null;
        return attribute.getEmails().stream()
                .map(email -> email.getAddress())
                .collect(Collectors.joining(","));
    }

    @Override
    public EmailSet convertToEntityAttribute(String dbData) {
        if (dbData == null) return null;
        String[] emails = dbData.split(",");
        Set<Email> emailSet = Arrays.stream(emails)
                .map(value -> new Email(value))
                .collect(toSet());
        return new EmailSet(emailSet);
    }
}

...

@Column(name = "emails")
@Convert(converter = EmailSetConverter.class)
private EmailSet emails;
```

### 밸류를 이용한 ID 매핑



# Chapter 5. 스피링 데이터 JPA

# Chapter 6. 응용 서비스와 표현 영역

# Chapter 7. 도메인 서비스

# Chapter 8. 애그러기트 트랜잭션

# Chapter 9. 도메인 모델과 바운디드 컨텍스트

# Chapter 10. 이벤트

# Chapter 11. CQRS