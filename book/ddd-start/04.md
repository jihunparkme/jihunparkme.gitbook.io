# Chapter 4. 리포지터리와 모델 구현

## JPA를 이용한 리포지터리 구현

**모듈 위치**

**리포지터리 인터페이스는 애그리거트와 같은 도메인 영역**에 속하고, **리포지터리를 구현한 클래스는 인프라스트럭처 영역**에 속한다.
- 기능하면 리토지터리 구현 클래스를 인프라스트럭처 영역에 위치 시켜서 인프라스트럭처에 대한 의존을 낮추자.

**리포지터리 기본 기능 구현**

리포지터리 인터페이스는 **애그리거트 루트를 기준**으로 작성하자.

```java
public interface OrderRepository {
    Optional<Order> findById(OrderNo no);
    void save(Order order);
    List<Order> findByOrdererId(String ordererId, int startRow, int size);
}
```

애그리거트 조회는 ID 외에도 JPA `Criteria`, `JPQL`을 사용할 수도 있다.

> 사용자가 삭제 기능을 실행할 때 데이터를 바로 삭제하기보다는 삭제 플래그를 사용해서 데이터를 화면에 보여줄지 여부를 결정하는 방식으로 구현하자.
>
> 관리자 기능에서 삭제 데이터 조회를 해야 하거나 데이터 원복을 위해 일정 기간 보관해야 할 경우도 있다.

## Spring Data JPA를 이용한 리포지터리 구현

스프링과 JPA를 함께 적용할 때는 Spring Data JPA를 사용한다.
- 지정한 규칙에 맞게 리포지터리 인터페이스를 정의하면 리포지터리를 구현한 객체를 알아서 만들어 스프링 빈으로 등록

아래 규칙에 따라 작성한 인터페이스를 찾아서 인터페이스를 구현한 스프링 빈 객체를 자동 등록
- `org.springframework.data.repository.Repository<T, ID>` 인터페이스 상속
- T는 엔티티 타입, ID는 식별자 타입

Spring Data JPA 사용을 위해 지정한 규칙에 맞게 메서드를 작성해야 한다.
- [JPA Query Methods](https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html#jpa.query-methods.query-creation)

## 매핑 구현

**엔티티와 밸류 기본 매핑 구현**

애그리거트와 JPA 매핑을 위한 기본 규칙
- 애그리거트 루트는 엔티티이므로 `@Entity` 매핑 설정

```java
@Entity
@Table(name = "purchase_order")
public class Order {
    @EmbeddedId
    private OrderNo number;

    @Embedded
    private Orderer orderer;

    @Embedded
    private ShippingInfo shippingInfo;
    ...
```

한 테이블에 엔티티와 밸류 데이터가 같이 있다면
- 밸류는 `@Embeddable`로 매핑 설정
- 밸류 타입 프로퍼티는 `@Embedded`로 매핑 설정

```java
@Embeddable
public class Orderer {

    @Embedded
    @AttributeOverrides( // 컬럼명과 실제 칼럼명이 다르므로 매핑 칼럼 변경        
        @AttributeOverride(name = "id", column = @Column(name = "orderer_id"))
    )
    private MemberId memberId; // Member 애그리거트를 ID로 참조

    @Column(name = "orderer_name")
    private String name;
    ...
}

...

@Embeddable
public class MemberId implements Serializable {
    @Column(name = "member_id")
    private String id;
}

@Embeddable
public class ShippingInfo {
    @Embedded
    @AttributeOverrides({ // 매핑 설정과 다른 컬럼 이름을 사용하기 위한 설정의 다른 예
            @AttributeOverride(name = "zipCode", column = @Column(name = "shipping_zip_code")),
            @AttributeOverride(name = "address1", column = @Column(name = "shipping_addr1")),
            @AttributeOverride(name = "address2", column = @Column(name = "shipping_addr2"))
    })
    private Address address;

    @Column(name = "shipping_message")
    private String message;

    @Embedded
    private Receiver receiver;
    ...
}
```

**기본 생성자**

앤티티와 밸류의 생성자는 객체를 생성할 때 **필요한 것을 전달** 받는다.
- 불변 타입이면 생성 시점에 필요한 값을 모두 전달받고, 값을 변경하는 set 메서드는 미제공
- 기본 생성자는 불필요

하지만, JPA에서 `@Entity`, `@Embeddable`로 클래스를 매핑하려면 기본 생성자를 제공해야 한다.
- DB에서 데이터를 읽어와 매핑 객체를 생성할 때 기본 생성자 사용

다른 코드에서 기본 생성자를 사용하지 못 하도록 protected 선언을 해주자.
- 기본 생성자는 JPA 프로바이더가 객체 생성 시에만 사용

```java
@Embeddable
public class Receiver {
    @Column(name = "receiver_name")
    private String name;

    @Column(name = "receiver_phone")
    private String phone;

    protected Receiver() {
    }

    public Receiver(String name, String phone) {
        this.name = name;
        this.phone = phone;
    }
    ...
}
```









# Chapter 5. 스피링 데이터 JPA

# Chapter 6. 응용 서비스와 표현 영역

# Chapter 7. 도메인 서비스

# Chapter 8. 애그러기트 트랜잭션

# Chapter 9. 도메인 모델과 바운디드 컨텍스트

# Chapter 10. 이벤트

# Chapter 11. CQRS