# 사작에 앞서

CQRS(Command and Query Responsibility Segregation)
- 명령 모델과 조회 모델을 분리하는 패턴
- `명령 모델`은 상태를 변경하는 기능을 구현할 때 사용(도메인 모델)
- `조회 모델`은 데이터를 조회하는 기능을 구현할 때 사용(조회 모델)

조회 모델을 구현할 때 **JPA, myBatis, jdbcTemplate 등 다양한 기술이 사용**된다.
- 모든 DB 연동 코드를 JPA만 사용해서 구현해야 한다고 생각하지 말자.

# 검색을 위한 스펙

`스펙`(Specification)
- 검색 조건을 다양하게 조합해야 할 때 사용할 수 있는 것
- 애그리거트가 특정 조건을 충족하는지를 검사할 때 사용하는 인터페이스

스펙 인터페이스 정의

```java
public interface Specification<T> {
    public boolean isSatisfiedBy(T agg);
}
```

스펙을 **리포지터리에 사용하면 agg(검사 대상 객체)는 애그리거트 루트**가 되고, 스펙을 **DAO에 사용하면 agg는 검색 결과**로 리턴할 데이터 객체가 된다.

isSatisfiedBy() 메서드는 검사 대상 객체가 조건을 충족하면 true, 그렇지 않으면 false 리턴

```java
public class OrdererSpec implements Specification<Order> {
	private String ordererId;
    ...

	public boolean isSatisfiedBy(Order agg) {
		return agg.getOrdererId().getMemberId().getId().equals(ordererId);
	}
}
```

리포지터리나 DAO는 **검색 대상을 걸러내는 용도**로 스펙을 사용

```java
public class MemoryOrderRepository implements OrderRepository {
    ...
    public List<Order> findAll(Specification<Order> spec) {
        List<Order> allOrders = findAll();
        return allOrders.stream()
                        .filter(order -> spec.isSatisfiedBy(order))
                        .toList();
    }
}
```

리포지터리가 스펙을 이용해서 검색 대상을 걸러주므로 특정 조건을 충족하는 애그리거트를 찾고 싶으면 **원하는 스펙을 생성해서 리포지터리에 전달**해 주기만 하면 된다.
- 실제 스펙은 이렇게 구현하지 않고, Spring Data JPA를 이용

```java
Specification<Order> ordererSpec = new OrdererSpec("madvirus");
List<Order> orders = orderRepository.findAll(ordererSpec);
```

# Spring Data JPA를 이용한 스펙 구현

Spring Data JPA는 검색 조건을 표현하기 위한 인터페이스인 `Specification` 제공
- 제네릭 타입 파라미터 `T`는 **JPA 엔티티 타입**
- `toPredicate()` 메서드는 JPA Criteria API에서 조건을 표현하는 **Predicate 생성**

```java
package org.springframework.data.jpa.domain;

public interface Specification<T> extends Serializable {
    ...

    @Nullable
    Predicate toPredicate(Root<T> root, 
                          CriteriaQuery<?> query, 
                          CriteriaBuilder criteriaBuilder);
}
```

엔티티 타입이 **OrderSummary**이고, **orderId** 프로퍼티 값이 지정한 값과 동일한 스펙
- OrderSummary에 대한 검색 조건 표현
- toPredicate() 메소드는 ordererId 프로퍼티 값이 생성자로 받은 ordererId와 동일한지 비교하는 Predicate 생성
- `OrderSummary_`는 JPA 정적 메타 모델.
  - 하이버네이트와 같은 JPA 프로바이더는 정적 메타 모델을 생성하는 도구를 제공

```java
public class OrdererIdSpec implements Specification<OrderSummary> {
	private String ordererId;
    ...

    @Override
	public Predicate toPredicate(Root<OrderSummary> root, 
                                CriteriaQuery<?> query, 
                                CriteriaBuilder cb) {
		return cb.equal(root.get(OrderSummary_.ordererId), ordererId);
	}
}
```

스펙 구현 클래스를 개별적으로 만들지 않고, 별도 클래스에 스펙 생성 기능을 모아도 된다.
- 스펙 인터페이스는 함수형 인터페이스이므로 람다식 이용도 가능

```java
public class OrderSummarySpecs {
    public static Specification<OrderSummary> ordererId(String ordererId) {
        return (Root<OrderSummary> root, CriteriaQuery<?> query, CriteriaBuilder cb) ->
                cb.equal(root.<String>get("ordererId"), ordererId);
    }

    public static Specification<OrderSummary> orderDateBetween(
            LocalDateTime from, LocalDateTime to) {
        return (Root<OrderSummary> root, CriteriaQuery<?> query, CriteriaBuilder cb) ->
                cb.between(root.get(OrderSummary_.orderDate), from, to);
    }
}

...

Specification<OrderSummary> betweenSpec = OrderSummarySpecs.orderDetailBetween(from, to);
```


















# 06. 응용 서비스와 표현 영역

# 07. 도메인 서비스

# 08. 애그리거트 트랜잭션 관리

# 09. 도메인 모델과 바운디드 컨텍스트

# 10. 이벤트

# 11. CQRS